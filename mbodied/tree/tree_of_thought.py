import logging
import uuid
import re
from mbodied.agents import LanguageAgent
from mbodied.types.sense.vision import Image
from mbodied.tree.prompt import create_llm_prompt, generate_prompt, Thought
from typing import List, Optional, Callable
from sklearn.decomposition import PCA
from sentence_transformers import SentenceTransformer

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ThoughtNode:
    def __init__(
        self,
        thought: str,
        embedding = None,
        parent: 'ThoughtNode' = None,
        evaluation: Optional[float] = None,
        n_components: int = 10
    ):
        """
        Initialize a ThoughtNode representing a decision/action embedding.
        
        Parameters:
        - thought: The action or decision.
        - embedding: The high-dimensional embedding of the action.
        - parent: The parent node if any.
        - evaluation: The score of this thought.
        - n_components: Number of components for reducing dimensionality.
        """
        self.id = str(uuid.uuid4())
        self.embedding = embedding
        self.reduced_embedding = None
        self.children: List['ThoughtNode'] = []
        self.thought = thought
        self.parent = parent
        self.evaluation = evaluation if evaluation is not None else 0.5
        if embedding is not None:
            self.pca_model = PCA(n_components=n_components)
            self.reduced_embedding = self.pca_model.fit_transform([embedding])[0]

    def __repr__(self):
        return f"Thought: {self.thought}, Eval: {self.evaluation}"

    def add_child(self, child_node: 'ThoughtNode') -> 'ThoughtNode':
        """
        Add a child node representing the next decision in the thought process.
        
        Parameters:
        - child_node: The ThoughtNode to be added to the children
        """
        self.children.append(child_node)
        logger.info(f"Added child node {child_node.id}")
        return child_node

    def is_leaf(self):
        return len(self.children) == 0


class TreeOfThought:
    def __init__(
        self,
        language_agent: 'LanguageAgent',
        n_components: int = 10,
        max_depth: int = 3,
        embed: bool = False
    ):
        """
        For reference, see: https://arxiv.org/pdf/2305.10601
        Initialize a Tree of Thought with a root node.
        
        Parameters:
        - language_agent: The LanguageAgent used to generate thoughts/actions.
        - n_components: Number of components/dimensions for PCA to reduce embeddings.
        - max_depth: Maximum depth allowed in the tree.
        - embed: Whether to generate embeddings for thoughts
        """
        self.root = None
        self.instruction = None
        self.image = None
        self.language_agent = language_agent
        self.n_components = n_components
        self.max_depth = max_depth
        self.embed = embed
        self.embedding_model = SentenceTransformer('paraphrase-MiniLM-L6-v2')
        self.best_path = []
        self.llm_best_path = []

    def generate_thoughts(
        self,
        instruction,
        image = None,
        parse_function: Optional[Callable[[str], List[str]]] = None
    ):
        """
        Query the Language Agent to generate actions/thoughts based on an instruction.
        
        Parameters:
        - instruction: The instruction to be sent to the Language Agent.
        - depth: The current depth of the thought tree (defaults to 0).
        - parse_function: A user-defined function to process the output of the LanguageAgent.
            This function takes the raw output as input and returns a list of thoughts or child states.
        - image: An image passed to the language agent.
        
        Returns:
        - A list of actions generated by the Language Agent.
        """
        self.instruction = instruction
        self.image = image
        try:
            response = self.language_agent.act(instruction, image)
        except Exception as e:
            logger.error(f"Language agent failed: {e}")
            return
        response = response.replace('```python\n', '').replace('\n```', '')
        actions = parse_function(response) if parse_function else [step.strip().strip('"').strip("'") for step in response.strip('[]').split(',')]
        self.language_agent.context = generate_prompt(instruction)
        logger.info(f"Generated actions: {actions}")
        self.root = ThoughtNode("Start")
        self._recursive_reasoning(
            node = self.root,
            thoughts = actions,
            evaluations = None,
            depth = 0,
            image = image
        )

    def _recursive_reasoning(
        self,
        node: 'ThoughtNode',
        thoughts: List[str],
        evaluations: List[float],
        depth: int,
        image: Image
    ):
        """
        Perform recursive reasoning by generating further thoughts from the current node.
        
        Parameters:
        - node: The current ThoughtNode to reason from.
        - depth: Current depth in the tree.
        """
        if depth >= self.max_depth or len(thoughts) == 0:
            logger.info("Max depth reached, stopping recursion.")
            return

        for i, thought in enumerate(thoughts):
            evaluation = evaluations[i] if evaluations else None
            embedding = None
            if self.embed:
                embedding = self._generate_embedding(thought)

            child_node = ThoughtNode(
                thought=thought,
                embedding=embedding,
                parent=node,
                evaluation=evaluation,
                n_components=self.n_components
            )
            child_node = node.add_child(child_node)

            try:
                response = self.language_agent.act_and_parse(thought, image, Thought)
            except Exception as e:
                logger.error(f"Language agent failed: {e}")
                return
            logger.info(f"Generated thought: {response.thought}, Evaluation: {response.evaluation}")

            self._recursive_reasoning(
                node = child_node,
                thoughts = response.thought,
                evaluations = response.evaluation,
                depth = depth + 1,
                image=image,
            )

    def _generate_embedding(self, thought: str):
        """
        Generate an embedding for a given thought using a pre-trained SentenceTransformer.
        
        Parameters:
        - thought: The thought/action to generate an embedding for.
        
        Returns:
        - A high-dimensional embedding for the thought.
        """
        embedding = self.embedding_model.encode(thought, convert_to_tensor=False)
        return embedding

    def get_actions(self, recompute: bool = False):
        """
        Fetch best action path

        parameters:
        - recompute: Boolean value which determines whether to recalculate best path 
        """
        if recompute or len(self.best_path) == 0:
            best_path = self._traverse(self.root)
            self.best_path = best_path
        print("Best Path:")
        for action in self.best_path:
            print(f"Action: {action}")

    def get_actions_from_llm(self, recompute: bool = False):
        """
        Generate the best path based on the given ThoughtNode tree using the LLM.
        parameters:
        - recompute: Boolean value which determines whether to recalculate best path
        """
        if recompute or len(self.llm_best_path) == 0:
            formatted_tree = self._format_thought_tree(self.root)
            self.language_agent.context = create_llm_prompt(formatted_tree, self.instruction)
            try:
                response = self.language_agent.act(self.instruction, self.image)
            except Exception as e:
                logger.error(f"Language agent failed: {e}")
                return
            response = response.replace('```python\n', '').replace('\n```', '')
            match = re.search(r'\[(.*?)\]', response)
            if match:
                command_list = match.group(0)
                self.llm_best_path = [step.strip().strip('"').strip("'") for step in command_list[1:-1].split(',')]
    
        print("Best Path:")
        for action in self.llm_best_path:
            print(f"Action: {action}")

    def get_depth(self, node: ThoughtNode) -> int:
        """
        Compute the depth of a node in the tree.
        
        Parameters:
        - node: The ThoughtNode to compute depth for.
        
        Returns:
        - Integer representing the depth.
        """
        depth = 0
        current = node
        while current != self.root:
            depth += 1
            current = current.parent
        return depth

    def traverse(self, node=None, level=0):
        """
        Traverse the tree of thought and print the structure.
        
        Parameters:
        - node: The current ThoughtNode to start traversal from. Defaults to root.
        - level: Depth level of the node in the tree.
        """
        if node is None:
            node = self.root
        
        print("  " * level + f"Level {level}: Thought: {node.thought} Evaluation: {node.evaluation}")

        for child in node.children:
            self.traverse(child, level + 1)
        
    def _action_exists(self, action: str, path: List[str]) -> bool:
        """
        Checks if the action already exists in the current path to avoid redundant steps.
        
        Args:
            action (str): The action to check.
            path (List[str]): The current path containing previously selected actions.

        Returns:
            bool: True if the action exists in the path, False otherwise.
        """
        return any(action in step for step in path)

    def _traverse(self, node: ThoughtNode) -> List[str]:
        """
        Performs depth-first traversal but avoids adding nodes with evaluation 0.5 unless they are leaf nodes.
        Gathers all children at each level, processes the breadth, and backtracks when required.

        Args:
            node (ThoughtNode): The root node of the thought tree.

        Returns:
            List[str]: The ordered list of actions based on depth-first traversal rules.
        """
        result = []
        visited = set()

        self._dfs_collect(node, result, visited)

        return result

    def _dfs_collect(self, node: ThoughtNode, result: List[str], visited: set):
        """
        Helper function to perform the DFS and collect thoughts as per the given rules.

        Args:
            node (ThoughtNode): Current node being traversed.
            result (List[str]): The result list where actions are being added.
            visited (set): Tracks visited thoughts to avoid duplicates.
        """
        if node.evaluation == 0.5 and not node.is_leaf():
            for child in node.children:
                self._dfs_collect(child, result, visited)
        else:
            if node.thought not in visited:
                visited.add(node.thought)
                result.append(node.thought)

            for child in node.children:
                self._dfs_collect(child, result, visited)

    def _format_thought_tree(self, node: ThoughtNode, level: int = 0) -> str:
        """
        Format the tree structure of thoughts into a readable string for the LLM.
        Parameters:
        - node: The root node of the thought tree.
        - level: The current level of depth in the tree (used for formatting).
        return: A string representing the thought tree.
        """
        formatted_str = f"{'  ' * level}Level {level}: Thought: {node.thought} Evaluation: {node.evaluation}\n"
        for child in node.children:
            formatted_str += self._format_thought_tree(child, level + 1)

        return formatted_str

if __name__ == "__main__":
    def run_thought_tree(instruction: str, language_agent, n_components: int = 3, max_depth: int = 3, image=None):
        """
        Initializes and runs the Tree of Thought process for a given instruction.
        
        Parameters:
        - instruction: The problem or task for the agent to reason about.
        - initial_embedding: The embedding for the root thought.
        - language_agent: The agent responsible for generating thoughts.
        - n_components: Number of components for PCA (default 3).
        - max_depth: Maximum depth of the thought tree (default 5).
        
        Returns:
        - The final tree of thought nodes.
        """
        thought_tree = TreeOfThought(language_agent=language_agent, n_components=n_components, max_depth=max_depth)

        thought_tree.generate_thoughts(instruction, image)
        
        return thought_tree

    import os

    image = Image(path="resources/color_image.png")
    cognition = LanguageAgent(
    context="You are an embodied planner that responds with a python list of strings and nothing else.",
    api_key=os.getenv("OPENAI_API_KEY"),
    model_src="openai",
    recorder="auto",
    )

    # Example Usage
    thought_tree = run_thought_tree("switch the positions of the remote and the fork", language_agent=cognition, image=image)
    thought_tree.traverse()
    thought_tree.get_actions()

    """
        Level 0: Thought: Start Evaluation: 0.5
    Level 1: Thought: Pick up the remote Evaluation: 0.5
        Level 2: Thought: move forward Evaluation: 8.0
        Level 3: Thought: grasp remote Evaluation: 9.0
        Level 3: Thought: lift remote Evaluation: 8.0
        Level 2: Thought: grasp remote Evaluation: 9.0
        Level 3: Thought: lift remote Evaluation: 8.0
        Level 2: Thought: lift remote Evaluation: 8.0
    Level 1: Thought: Place the remote where the fork is Evaluation: 0.5
        Level 2: Thought: move to fork location Evaluation: 8.0
        Level 3: Thought: place remote Evaluation: 9.0
        Level 2: Thought: place remote Evaluation: 9.0
    Level 1: Thought: Pick up the fork Evaluation: 0.5
        Level 2: Thought: move to fork Evaluation: 8.0
        Level 3: Thought: grasp fork Evaluation: 9.0
        Level 3: Thought: lift fork Evaluation: 8.0
        Level 2: Thought: grasp fork Evaluation: 9.0
        Level 3: Thought: lift fork Evaluation: 8.0
        Level 2: Thought: lift fork Evaluation: 8.0
    Level 1: Thought: Place the fork where the remote was Evaluation: 0.5
        Level 2: Thought: move to remote location Evaluation: 8.0
        Level 3: Thought: place fork Evaluation: 9.0
        Level 2: Thought: place fork Evaluation: 9.0

    Best Path:
    Action: move forward
    Action: grasp remote
    Action: lift remote
    Action: move to fork location
    Action: place remote
    Action: move to fork
    Action: grasp fork
    Action: lift fork
    Action: move to remote location
    Action: place fork
    """